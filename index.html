
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumVibes - Interactive Quantum Simulations by Trent Sterling</title>
    <meta name="description" content="Explore the mysteries of quantum mechanics with QuantumVibes, interactive Double-Slit and Path Integral simulations. Witness wave-particle duality and Feynman's path integrals. Vibecoded by Trent Sterling (Tront).">
    <meta name="keywords" content="QuantumVibes, quantum physics, double-slit experiment, path integral, Feynman diagrams, wave-particle duality, quantum simulation, interactive physics, physics visualization, Trent Sterling, Tront, HTML5 canvas, JavaScript simulation, web worker">
    <link rel="canonical" href="https://tront.xyz/quantumvibes/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tront.xyz/quantumvibes/">
    <meta property="og:title" content="QuantumVibes - Interactive Quantum Simulations by Trent Sterling">
    <meta property="og:description" content="Explore wave-particle duality with interactive Double-Slit and Feynman's Path Integral simulations. Vibecoded by Trent Sterling (Tront).">
    <meta property="og:image" content="https://blog.tront.xyz/assets/img/tront.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="400">
    <meta property="og:image:height" content="400">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://tront.xyz/quantumvibes/">
    <meta name="twitter:title" content="QuantumVibes - Interactive Quantum Simulations by Trent Sterling">
    <meta name="twitter:description" content="Explore wave-particle duality with interactive Double-Slit and Feynman's Path Integral simulations. Vibecoded by Trent Sterling (Tront).">
    <meta name="twitter:image" content="https://blog.tront.xyz/assets/img/tront.png">

    <link rel="icon" href="https://blog.tront.xyz/assets/img/tront.png" type="image/png">
    <style>
        /* CSS unchanged */
        body { background-color: #1e1e1e; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; padding-top: clamp(10px, 1.5vh, 20px); padding-bottom: clamp(10px, 1.5vh, 20px); font-size: clamp(10px, 0.9vw + 0.1vh, 16px); }
        #mainContainer { background-color: #2a2a2a; padding: clamp(10px, 1.5vw, 20px); border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.6); width: clamp(700px, 90vw, 2200px); display: flex; flex-direction: column; gap: clamp(10px, 1.5vw, 20px); }
        #controlsContainer { background-color: #333; padding: clamp(0.8em, 1vw, 1.2em) clamp(1em, 1.5vw, 1.5em); border-radius: 5px; display: flex; flex-direction: column; gap: clamp(0.8em, 1.2vw, 1.2em); width: 100%; box-sizing: border-box; }
        .top-button-row { display: flex; gap: clamp(0.5em, 0.8vw, 0.8em); align-items: center; flex-wrap: wrap; }
        .control-group { border: 1px solid #4a4a4a; padding: clamp(0.8em, 1.2vw, 1.2em) clamp(1em, 1.8vw, 1.5em); border-radius: 4px; }
        .control-group h3 { margin-top: 0; margin-bottom: clamp(0.8em, 1.2vw, 1.2em); font-size: clamp(1.1em, 1.5vw, 1.4em); color: #00b3ff; border-bottom: 1px solid #4a4a4a; padding-bottom: clamp(0.4em, 0.6vw, 0.6em); }
        button { background-color: #4f4f4f; color: #e0e0e0; border: 1px solid #666; padding: clamp(0.5em, 0.7vw, 0.8em) clamp(0.8em, 1.2vw, 1.2em); border-radius: 4px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s; font-size: clamp(0.85em, 1.1vw, 1.1em); }
        button:hover { background-color: #5a5a5a; border-color: #777; }
        button.active { background-color: #007acc; color: white; border-color: #005c99; box-shadow: 0 0 8px rgba(0,122,204,0.7); }
        .control-row[title]:hover { position: relative; }
        .control-row[title]:hover::after { content: attr(title); position: absolute; left: 0; top: 100%; background-color: #222; color: #ddd; padding: 0.5em 0.8em; border-radius: 4px; font-size: 0.85em; white-space: nowrap; z-index: 10; border: 1px solid #555; box-shadow: 0 2px 5px rgba(0,0,0,0.3); margin-top: 0.3em; pointer-events: none; }
        input[type="range"] { flex-grow: 1; cursor: pointer; margin-left: 0.5em; min-width: 10em; }
        label { display: flex; align-items: center; gap: 0.5em; font-size: clamp(0.9em, 1.2vw, 1.1em); min-width: 17em; }
        label span { color: #00b3ff; font-weight: bold; min-width: 3.8em; text-align: right; margin-right: 0.3em; }
        input[type="checkbox"] { cursor: pointer; transform: scale(1.15); margin-right: 0.6em; accent-color: #007acc; }
        canvas { background-color: #000000; border: 1px solid #555; display: block; border-radius: 3px; width: 100%; height: auto; cursor: default;}
        canvas.pi-hover { cursor: grab; }
        canvas.pi-dragging { cursor: grabbing; }
        .perf-stats { font-size: clamp(0.9em, 1.1vw, 1.1em); color: #bbb; margin-left: auto; padding-right: 1em; white-space: nowrap; }
        .perf-stats #workerParticleCount { margin-left: 0.5em; }
        .ds-columns-container { display: flex; justify-content: space-between; gap: clamp(1em, 2vw, 1.5em); flex-wrap: wrap;}
        .ds-column { flex: 1; display: flex; flex-direction: column; gap: clamp(0.7em, 1vw, 1em); min-width: 300px;}
        .ds-column .control-row { margin-bottom: 0; display: flex; align-items: center; }
        .ds-column .control-row label { flex-shrink: 0; }
        .ds-column .control-row label[for="observer"] { min-width: unset; }
        .description-box { background-color: #333; color: #ccc; padding: clamp(0.8em, 1.2vw, 1.2em) clamp(1em, 1.5vw, 1.5em); border-radius: 4px; border: 1px solid #4a4a4a; font-size: clamp(0.85em, 1.1vw, 1.05em); line-height: 1.6; margin-top: clamp(10px, 1.5vw, 15px); }
        .description-box h4 { margin-top: 0; color: #00aeff; font-size: 1.1em; }
        .description-box p, .description-box ul { margin-bottom: 0.7em; }
        .description-box ul { margin-top: 0.3em; padding-left: 1.5em;}
        .description-box li { margin-bottom: 0.3em; }
        .description-box strong { color: #e0e0e0; }
        .footer-attribution { text-align: center; margin-top: clamp(20px, 3vh, 40px); padding-bottom: clamp(10px, 1.5vh, 20px); font-size: clamp(0.8em, 1vw, 1em); color: #888; }
        .footer-attribution p { margin-bottom: 0.25em; line-height: 1.4;}
        .footer-attribution a { color: #00aeff; text-decoration: none; }
        .footer-attribution a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div id="mainContainer">
        <!-- ALL EXISTING APP CONTENT (CONTROLS, CANVAS, DESCRIPTIONS) REMAINS UNCHANGED -->
        <div id="controlsContainer">
            <div class="top-button-row">
                <button id="btnDoubleSlit" class="active">Double Slit</button>
                <button id="btnPathIntegral">Path Integral</button>
                <button id="btnResetSimulation" style="margin-left: clamp(0.5em, 1vw, 1em);" title="Clears current simulation data and restarts.">Reset Simulation</button>
                <button id="btnResetDefaults" title="Resets all settings to their original defaults and clears the simulation.">Reset Defaults</button>
                <div class="perf-stats">
                    FPS: <span id="fpsDisplay">--</span> | Vis Parts: <span id="particleCountDisplay">--</span>
                    <span id="workerParticleCountLabel" style="display:none;">| Worker Hits: <span id="workerParticleCount">0</span></span>
                </div>
            </div>
            <div id="doubleSlitControls" class="control-group">
                 <h3>Double Slit Controls</h3>
                 <div class="ds-columns-container">
                     <div class="ds-column">
                         <div class="control-row" title="Distance between the centers of the two slits.">
                             <label for="slitSeparation">Slit Separation: <span id="slitSeparationValue"></span>px</label>
                             <input type="range" id="slitSeparation" min="10" max="200">
                         </div>
                         <div class="control-row" title="Vertical opening size of each slit.">
                             <label for="slitHeight">Slit Height (Aperture): <span id="slitHeightValue"></span>px</label>
                             <input type="range" id="slitHeight" min="5" max="100">
                         </div>
                         <div class="control-row" title="Controls effective particle wavelength (λ ≈ C/speed).">
                             <label for="lambdaConstant">Wave Constant (λ ~ C/v): <span id="lambdaConstantValue"></span></label>
                             <input type="range" id="lambdaConstant" min="10" max="500" step="5">
                         </div>
                         <div class="control-row" title="Simulation speed multiplier for the background worker thread. Does NOT affect visual particle speed.">
                            <label for="simulationSpeedMultiplier">Sim Speed Multiplier: <span id="simulationSpeedMultiplierValue"></span>x</label>
                            <input type="range" id="simulationSpeedMultiplier" min="1" max="20" step="1">
                        </div>
                     </div>
                     <div class="ds-column">
                         <div class="control-row" title="Target simulation rate (particles/sec) for the background worker.">
                             <label for="particleRate">Sim Rate (Worker): <span id="particleRateValue"></span> p/s</label>
                             <input type="range" id="particleRate" min="100" max="100000" step="100">
                         </div>
                         <div class="control-row" title="Base speed of individual particles (visual and worker).">
                             <label for="particleSpeed">Particle Speed: <span id="particleSpeedValue"></span> px/f</label>
                             <input type="range" id="particleSpeed" min="1" max="20" step="0.1">
                         </div>
                          <div class="control-row" title="Amount of random angular deflection for observed particles.">
                             <label for="observerKickStrength">Observer Kick Strength: <span id="observerKickStrengthValue"></span></label>
                             <input type="range" id="observerKickStrength" min="0.0" max="0.5" step="0.01">
                         </div>
                         <div class="control-row" style="padding-top: 0.8em; justify-content: flex-start;" title="Toggle wave vs particle behavior. Resets simulation.">
                             <label for="observer"><input type="checkbox" id="observer"> Observer Active (Particle-like)</label>
                         </div>
                     </div>
                 </div>
             </div>
             <div id="pathIntegralControls" class="control-group" style="display:none;">
                 <h3>Path Integral Controls</h3>
                 <div class="control-row" title="Total number of random paths sampled from point A to B.">
                    <label for="numPaths">Number of Paths: <span id="numPathsValue"></span></label>
                    <input type="range" id="numPaths" min="10" max="2000" step="10">
                </div>
                <div class="control-row" title="Maximum random sideways deviation (wiggle) for path segments.">
                    <label for="wiggleAmplitude">Wiggle Amplitude: <span id="wiggleAmplitudeValue"></span>px</label>
                    <input type="range" id="wiggleAmplitude" min="0" max="300">
                </div>
                <div class="control-row" title="Number of straight line segments used to construct each random path.">
                    <label for="numSegments">Segments per Path: <span id="numSegmentsValue"></span></label>
                    <input type="range" id="numSegments" min="1" max="50">
                </div>
            </div>
        </div>
        <canvas id="simulationCanvas"></canvas>
        <div id="doubleSlitDescription" class="description-box">
             <h4>The Double-Slit Experiment: Unveiling Quantum Mystery</h4>
             <p>This simulation demonstrates wave-particle duality. The histogram (particle count on the right) is built rapidly by a background Web Worker simulating many particles. A separate, fixed number of purely visual particles are simulated on the main thread for smooth animation (their speed is unaffected by "Sim Speed Multiplier").</p>
             <h5>Wave-like Behavior (Observer OFF)</h5>
             <p>Particles behave like waves, passing through <em>both slits simultaneously</em> and interfering, creating the characteristic <strong>interference pattern</strong> in the histogram.</p>
             <h5>Particle-like Behavior (Observer ON)</h5>
             <p>Observing which slit a particle uses forces it to act like a particle, going through only one slit. The interference pattern vanishes, replaced by <strong>two distinct clumps</strong> in the histogram.</p>
             <p>Use <strong>Sim Speed Multiplier</strong> (affects worker only) and <strong>Sim Rate (Worker)</strong> to accelerate histogram accumulation. Changing any slider/toggle resets the simulation.</p>
         </div>
         <div id="pathIntegralDescription" class="description-box" style="display:none;">
             <h4>Path Integral Explorer</h4>
             <p>Illustrates Feynman's Path Integral formulation: a particle explores <strong>all possible paths simultaneously</strong> from A to B. Each path's "action" (simplified as length) determines its contribution. Paths near the <strong>least action path (bright green)</strong> contribute most. Drag A & B (paths update on release) or use sliders (paths update after you stop) to explore.</p>
         </div>
    </div>

    <!-- === MODIFIED FOOTER SECTION for Interlinking === -->
    <div class="footer-attribution">
        <p>QuantumVibes. Vibecoded by Trent Sterling (Tront), May 2025.</p>
        <p>
            <a href="readme.html" target="_blank" rel="noopener noreferrer">About This Project (The Story)</a> | 
            Explore more from Tront: <a href="https://tront.xyz/" target="_blank" rel="noopener noreferrer">tront.xyz</a> |
            <a href="https://github.com/TrentSterling/quantumvibes" target="_blank" rel="noopener noreferrer">View on GitHub</a>
        </p>
        <p>&copy; <span id="current-year-qv">2025</span> Trent Sterling. All rights reserved.</p>
    </div>
    <!-- === END OF MODIFIED FOOTER SECTION === -->

    <script id="particleWorkerSource" type="javascript/worker">
        // Worker script unchanged
        let workerDsState = { particles: [], histogram: new Array(100).fill(0), HISTOGRAM_BINS: 100, emitterX: 0, emitterY: 0, barrierX: 0, barrierThickness: 0, detectorX: 0, detectorStartY: 0, detectorHeight: 0, canvasWidth: 0, canvasHeight: 0, };
        let workerDsParams = {};
        let timeSinceLastEmission_worker = 0;
        let lastWorkerLoopTime = 0;
        let workerSimIntervalId = null;
        let totalSimulatedInWorker = 0;
        const HISTOGRAM_BATCH_SIZE = 200;
        let histogramUpdateCount = 0;
        function emitParticle_worker() { const angle = (Math.random() - 0.5) * 0.6; const speed_scaled = workerDsParams.particleSpeed * (workerDsState.canvasWidth / 900); workerDsState.particles.push({ x: workerDsState.emitterX, y: workerDsState.emitterY, vx: speed_scaled * Math.cos(angle), vy: speed_scaled * Math.sin(angle), age: 0, maxAge: (workerDsState.canvasWidth / Math.max(0.1, speed_scaled)) * 1.6, isWave: !workerDsParams.observer, passedSlitPlane: false, slitPassed: 0, id: Math.random() }); }
        function updateSimulation_worker(deltaTime) { if (!workerDsParams.particleRate) return; timeSinceLastEmission_worker += deltaTime; const emissionInterval = 1000 / workerDsParams.particleRate; let emittedThisFrame = 0; while (timeSinceLastEmission_worker >= emissionInterval) { if (workerDsState.particles.length < 100000) { emitParticle_worker(); emittedThisFrame++; } timeSinceLastEmission_worker -= emissionInterval; } totalSimulatedInWorker += emittedThisFrame; for (let i = workerDsState.particles.length - 1; i >= 0; i--) { const p = workerDsState.particles[i]; const prevX = p.x; p.x += p.vx; p.y += p.vy; p.age++; if (p.age > p.maxAge || p.x < -10 || p.y < -10 || p.y > workerDsState.canvasHeight + 10 || p.x > workerDsState.canvasWidth + 20) { workerDsState.particles.splice(i, 1); continue; } if (!p.passedSlitPlane && p.x >= workerDsState.barrierX && prevX < workerDsState.barrierX + workerDsState.barrierThickness) { let yAtBarrierFront = p.y; if (prevX < workerDsState.barrierX && p.x >= workerDsState.barrierX) { const t = (workerDsState.barrierX - prevX) / (p.vx || 1e-6); yAtBarrierFront = (p.y - p.vy) + p.vy * t; } p.passedSlitPlane = true; const actualSlitSeparation = workerDsParams.slitSeparation * (workerDsState.canvasHeight / 400); const actualSlitHeight = workerDsParams.slitHeight * (workerDsState.canvasHeight / 400); const slit1_y_top = workerDsState.emitterY - actualSlitSeparation / 2 - actualSlitHeight / 2; const slit1_y_bottom = slit1_y_top + actualSlitHeight; const slit2_y_top = workerDsState.emitterY + actualSlitSeparation / 2 - actualSlitHeight / 2; const slit2_y_bottom = slit2_y_top + actualSlitHeight; const inSlit1 = (yAtBarrierFront >= slit1_y_top && yAtBarrierFront <= slit1_y_bottom); const inSlit2 = (yAtBarrierFront >= slit2_y_top && yAtBarrierFront <= slit2_y_bottom); if (!inSlit1 && !inSlit2 && p.x < workerDsState.barrierX + workerDsState.barrierThickness) { workerDsState.particles.splice(i, 1); continue; } if (!inSlit1 && !inSlit2) { workerDsState.particles.splice(i, 1); continue; } let y_final_on_detector; const distSlitScreen = workerDsState.detectorX - workerDsState.barrierX; const speed_scaled = workerDsParams.particleSpeed * (workerDsState.canvasWidth / 900); if (p.isWave) { p.slitPassed = inSlit1 ? 1 : (inSlit2 ? 2 : 0); const lambda = workerDsParams.lambdaConstant / Math.max(0.1, speed_scaled); let attempts = 0; const MAX_ATTEMPTS = 250; while (attempts < MAX_ATTEMPTS) { const rand_y_rel = (Math.random() - 0.5) * (workerDsState.detectorHeight * 1.5); const sinc_arg = (Math.PI * actualSlitHeight * rand_y_rel) / (lambda * distSlitScreen); let diff_factor = (Math.abs(sinc_arg) > 1e-6) ? Math.pow(Math.sin(sinc_arg) / sinc_arg, 2) : 1.0; const int_arg = Math.PI * actualSlitSeparation * rand_y_rel / (lambda * distSlitScreen); const int_factor = Math.pow(Math.cos(int_arg), 2); if (Math.random() < (diff_factor * int_factor)) { y_final_on_detector = workerDsState.emitterY + rand_y_rel; break; } attempts++; } if (y_final_on_detector === undefined) {  const target_y_offset = (yAtBarrierFront - workerDsState.emitterY) * (distSlitScreen / (workerDsState.barrierX - workerDsState.emitterX)); y_final_on_detector = workerDsState.emitterY + target_y_offset; } } else { p.slitPassed = inSlit1 ? 1 : 2; const y_slit_center = (p.slitPassed === 1) ? (slit1_y_top + actualSlitHeight / 2) : (slit2_y_top + actualSlitHeight / 2); const ideal_y = workerDsState.emitterY + (y_slit_center - dsState.emitterY) * (workerDsState.detectorX - workerDsState.emitterX) / (workerDsState.barrierX - dsState.emitterX); const max_spread = distSlitScreen * Math.tan(workerDsParams.observerKickStrength); y_final_on_detector = ideal_y + (Math.random() - 0.5) * 2 * max_spread; } const angle_target = Math.atan2(y_final_on_detector - p.y, workerDsState.detectorX - p.x); p.vx = speed_scaled * Math.cos(angle_target); p.vy = speed_scaled * Math.sin(angle_target); } if (p.x - p.vx < workerDsState.detectorX && p.x >= workerDsState.detectorX) { const t = (workerDsState.detectorX - (p.x - p.vx)) / (p.vx || 1e-6); const y_at_detector = (p.y - p.vy) + p.vy * t; if (y_at_detector >= workerDsState.detectorStartY && y_at_detector <= workerDsState.detectorStartY + workerDsState.detectorHeight) { const binIndex = Math.floor(((y_at_detector - workerDsState.detectorStartY) / workerDsState.detectorHeight) * workerDsState.HISTOGRAM_BINS); if (binIndex >= 0 && binIndex < workerDsState.HISTOGRAM_BINS) { workerDsState.histogram[binIndex]++; histogramUpdateCount++; } } workerDsState.particles.splice(i, 1); continue; } } if (histogramUpdateCount >= HISTOGRAM_BATCH_SIZE) { self.postMessage({ type: 'histogram_batch', histogram: workerDsState.histogram, totalSimulated: totalSimulatedInWorker }); histogramUpdateCount = 0; } }
        function workerLoop() { const now = performance.now(); const deltaTime = now - (lastWorkerLoopTime || now); lastWorkerLoopTime = now; const effectiveDeltaTime = Math.min(deltaTime, 100); const multiplier = workerDsParams.simulationSpeedMultiplier || 1; for (let i = 0; i < multiplier; i++) { updateSimulation_worker(effectiveDeltaTime / multiplier); } }
        self.onmessage = function(e) { const msg = e.data; switch(msg.type) { case 'init': case 'params_update': workerDsParams = msg.dsParams; workerDsState = { ...workerDsState, ...msg.simGeometry }; workerDsState.particles = []; workerDsState.histogram.fill(0); totalSimulatedInWorker = 0; histogramUpdateCount = 0; timeSinceLastEmission_worker = 0; lastWorkerLoopTime = performance.now(); if (!workerSimIntervalId && workerDsParams.particleRate > 0) { workerSimIntervalId = setInterval(workerLoop, 16); } else if (workerSimIntervalId && (workerDsParams.particleRate === 0 || !workerDsParams.particleRate)) { clearInterval(workerSimIntervalId); workerSimIntervalId = null; } self.postMessage({ type: 'histogram_batch', histogram: workerDsState.histogram, totalSimulated: totalSimulatedInWorker }); break; case 'reset': workerDsState.particles = []; workerDsState.histogram.fill(0); totalSimulatedInWorker = 0; histogramUpdateCount = 0; timeSinceLastEmission_worker = 0; self.postMessage({ type: 'histogram_batch', histogram: workerDsState.histogram, totalSimulated: totalSimulatedInWorker }); break; } };
    </script>

    <script>
        // Main JavaScript unchanged
        let currentMode = 'double-slit';
        let canvas, ctx, animationFrameId;
        let lastTimestamp = 0; 
        let frameCount = 0, lastFpsUpdate = 0;
        let fpsDisplay, particleCountDisplay, workerParticleCountLabel, workerParticleCountDisplay;

        const DESIGN_WIDTH = 900; const DESIGN_HEIGHT = 400;
        let particleWorker;
        let mainThreadTimeSinceLastEmission = 0;
        
        const MAIN_THREAD_MAX_VISUALS = 500; 
        const MAIN_THREAD_EMISSION_RATE_LIMIT = 1000;

        const dsState = { mainThreadParticles: [], histogram: new Array(100).fill(0), maxHistogramValue: 0, HISTOGRAM_BINS: 100, emitterX_base: 30, emitterY_base_factor: 0.5, barrierX_base_factor: 0.5, barrierThickness_base: 30, detectorX_base_from_right: 150, detectorWidth_base: 5, detectorHeight_base_factor: 0.9, detectorStartY_base_factor: 0.05, emitterX: 0, emitterY: 0, barrierX: 0, barrierThickness: 0, detectorX: 0, detectorWidth: 0, detectorHeight: 0, detectorStartY: 0, };
        
        const dsParams_initial = {
            slitSeparation: 34, slitHeight: 11, particleRate: 10000, particleSpeed: 10,   
            lambdaConstant: 215, observer: false, observerKickStrength: 0.06,
            simulationSpeedMultiplier: 10, 
        };
        let dsParams = { ...dsParams_initial };

        const piState = { paths: [], minActionPath: null, minAction: Infinity, maxAction: 0, pointA_x_base: 50, pointA_y_base_from_bottom: 50, pointB_x_base_from_right: 50, pointB_y_base_from_top: 50, pointA: {}, pointB: {}, draggingPoint: null, dragPointRadius_base: 7, needsRedraw: true, offscreenCanvas: null, offscreenCtx: null, };
        const piParams_initial = { numPaths: 150, wiggleAmplitude: 100, numSegments: 15 };
        let piParams = { ...piParams_initial };
        const PI_CONSTS = { MIN_PATH_OPACITY: 0.01, MAX_PATH_OPACITY: 0.45 };

        function debounce(func, delay) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
        const debouncedGeneratePathsForSliders = debounce(() => { if (currentMode === 'path-integral') { generatePaths(); } }, 250);

        window.addEventListener('DOMContentLoaded', () => {
             canvas = document.getElementById('simulationCanvas'); ctx = canvas.getContext('2d');
             fpsDisplay = document.getElementById('fpsDisplay'); particleCountDisplay = document.getElementById('particleCountDisplay');
             workerParticleCountLabel = document.getElementById('workerParticleCountLabel'); workerParticleCountDisplay = document.getElementById('workerParticleCount');
             piState.offscreenCanvas = document.createElement('canvas'); piState.offscreenCtx = piState.offscreenCanvas.getContext('2d');
             try { const workerScriptContent = document.getElementById('particleWorkerSource').textContent; const workerBlob = new Blob([workerScriptContent], { type: 'application/javascript' }); particleWorker = new Worker(URL.createObjectURL(workerBlob)); particleWorker.onmessage = handleWorkerMessage;
             } catch (e) { console.error("Failed to initialize Web Worker:", e); alert("Error: Could not start simulation worker."); }
             setupControls(); updateAllControlDisplays();
             resizeCanvasAndSim(); window.addEventListener('resize', debounce(resizeCanvasAndSim, 150));
             setupCanvasMouseEvents(); animationLoop(0);

             // Initialize current year in footer
            const currentYearQvEl = document.getElementById('current-year-qv');
            if (currentYearQvEl) {
                currentYearQvEl.textContent = new Date().getFullYear();
            }
         });
        
        function getSimGeometry() { return { emitterX: dsState.emitterX, emitterY: dsState.emitterY, barrierX: dsState.barrierX, barrierThickness: dsState.barrierThickness, detectorX: dsState.detectorX, detectorStartY: dsState.detectorStartY, detectorHeight: dsState.detectorHeight, canvasWidth: canvas.width, canvasHeight: canvas.height }; }
        
        function resizeCanvasAndSim() {
            const mainContainer = document.getElementById('mainContainer');
            const containerWidth = mainContainer.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth * (DESIGN_HEIGHT / DESIGN_WIDTH);

            if (piState.offscreenCanvas) {
                piState.offscreenCanvas.width = canvas.width;
                piState.offscreenCanvas.height = canvas.height;
            }
            dsState.emitterX = canvas.width * (dsState.emitterX_base / DESIGN_WIDTH);
            dsState.emitterY = canvas.height * dsState.emitterY_base_factor;
            dsState.barrierThickness = Math.max(1, canvas.width * (dsState.barrierThickness_base / DESIGN_WIDTH));
            dsState.barrierX = canvas.width * dsState.barrierX_base_factor - dsState.barrierThickness / 2;
            dsState.detectorX = canvas.width - (canvas.width * (dsState.detectorX_base_from_right / DESIGN_WIDTH));
            dsState.detectorWidth = Math.max(1, canvas.width * (dsState.detectorWidth_base / DESIGN_WIDTH));
            dsState.detectorHeight = canvas.height * dsState.detectorHeight_base_factor;
            dsState.detectorStartY = canvas.height * dsState.detectorStartY_base_factor;

            if(piState.pointA) { 
                piState.pointA.x = canvas.width * (piState.pointA_x_base / DESIGN_WIDTH);
                piState.pointA.y = canvas.height - (canvas.height * (piState.pointA_y_base_from_bottom / DESIGN_HEIGHT));
            }
            if(piState.pointB) { 
                piState.pointB.x = canvas.width - (canvas.width * (piState.pointB_x_base_from_right / DESIGN_WIDTH));
                piState.pointB.y = canvas.height * (piState.pointB_y_base_from_top / DESIGN_HEIGHT);
            }

            if (ctx) resetSimulationState();
        }
        
        function resetSimulationState() { dsState.mainThreadParticles = []; clearHistogram(); mainThreadTimeSinceLastEmission = 0; if (currentMode === 'double-slit' && particleWorker) { particleWorker.postMessage({ type: 'params_update', dsParams: dsParams, simGeometry: getSimGeometry() }); workerParticleCountLabel.style.display = 'inline'; } else if (currentMode === 'path-integral' && ctx && piState.offscreenCtx) { piState.paths = []; piState.minAction = Infinity; piState.maxAction = 0; piState.minActionPath = null; piState.needsRedraw = true; generatePaths(); workerParticleCountLabel.style.display = 'none'; } }
        function handleWorkerMessage(e) { const msg = e.data; if (msg.type === 'histogram_batch') { dsState.histogram = msg.histogram; dsState.maxHistogramValue = 0; for (let i = 0; i < dsState.HISTOGRAM_BINS; i++) { if (dsState.histogram[i] > dsState.maxHistogramValue) { dsState.maxHistogramValue = dsState.histogram[i]; } } if (workerParticleCountDisplay) workerParticleCountDisplay.textContent = msg.totalSimulated.toLocaleString(); } }
        function clearHistogram() { dsState.histogram.fill(0); dsState.maxHistogramValue = 0; if (workerParticleCountDisplay) workerParticleCountDisplay.textContent = '0'; if (particleWorker && currentMode === 'double-slit') particleWorker.postMessage({ type: 'reset' }); }
        function resetToDefaults() { Object.assign(dsParams, dsParams_initial); Object.assign(piParams, piParams_initial); updateAllControlDisplays(); resetSimulationState(); }
        
        function updateAllControlDisplays() {
            Object.keys(dsParams_initial).forEach(id => { 
                const input = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                if (dsParams.hasOwnProperty(id)) {
                    if (input) {
                        if (input.type === 'checkbox') input.checked = dsParams[id];
                        else input.value = dsParams[id];
                    }
                    if (valueSpan) valueSpan.textContent = dsParams[id];
                }
            });
            Object.keys(piParams_initial).forEach(id => {
                const input = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                if (piParams.hasOwnProperty(id)) {
                    if (input) input.value = piParams[id];
                    if (valueSpan) valueSpan.textContent = piParams[id];
                }
            });
        }

        function setupControls() { document.getElementById('btnDoubleSlit').addEventListener('click', () => switchMode('double-slit')); document.getElementById('btnPathIntegral').addEventListener('click', () => switchMode('path-integral')); document.getElementById('btnResetSimulation').addEventListener('click', resetSimulationState); document.getElementById('btnResetDefaults').addEventListener('click', resetToDefaults); 
            Object.keys(dsParams_initial).forEach(id => { 
                const input = document.getElementById(id);
                if (!input) return; 
                const eventType = input.type === 'checkbox' ? 'change' : 'input';
                input.addEventListener(eventType, (e) => {
                    if (input.type === 'checkbox') dsParams[id] = e.target.checked;
                    else dsParams[id] = parseFloat(e.target.value);
                    const valueSpan = document.getElementById(id + 'Value');
                    if (valueSpan) valueSpan.textContent = (input.type === 'checkbox' ? dsParams[id] : e.target.value);
                    if (currentMode === 'double-slit') { 
                        resetSimulationState();
                    }
                });
            });
            Object.keys(piParams).forEach(id => { const input = document.getElementById(id); if (!input) return; input.addEventListener('input', (e) => { piParams[id] = parseFloat(e.target.value); document.getElementById(id + 'Value').textContent = e.target.value; if (currentMode === 'path-integral') debouncedGeneratePathsForSliders(); }); });
        }

        function switchMode(mode) { currentMode = mode; document.getElementById('btnDoubleSlit').classList.toggle('active', mode === 'double-slit'); document.getElementById('btnPathIntegral').classList.toggle('active', mode === 'path-integral'); document.getElementById('doubleSlitControls').style.display = (mode === 'double-slit') ? 'block' : 'none'; document.getElementById('pathIntegralControls').style.display = (mode === 'path-integral') ? 'block' : 'none'; document.getElementById('doubleSlitDescription').style.display = (mode === 'double-slit') ? 'block' : 'none'; document.getElementById('pathIntegralDescription').style.display = (mode === 'path-integral') ? 'block' : 'none'; workerParticleCountLabel.style.display = (mode === 'double-slit') ? 'inline' : 'none'; canvas.className = ''; resetSimulationState(); }
        function setupCanvasMouseEvents() { let rect = canvas.getBoundingClientRect(); canvas.addEventListener('mousedown', (e) => { if (currentMode !== 'path-integral') return; rect = canvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height); const scaledRadius = piState.dragPointRadius_base * (canvas.width / DESIGN_WIDTH) * 1.5; if (Math.hypot(mouseX - piState.pointA.x, mouseY - piState.pointA.y) < scaledRadius) { piState.draggingPoint = 'A'; } else if (Math.hypot(mouseX - piState.pointB.x, mouseY - piState.pointB.y) < scaledRadius) { piState.draggingPoint = 'B'; } if (piState.draggingPoint) { canvas.classList.add('pi-dragging'); canvas.classList.remove('pi-hover'); piState.needsRedraw = true; } }); canvas.addEventListener('mousemove', (e) => { if (currentMode !== 'path-integral') return; rect = canvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height); if (piState.draggingPoint) { const targetPoint = piState.draggingPoint === 'A' ? piState.pointA : piState.pointB; targetPoint.x = Math.max(0, Math.min(canvas.width, mouseX)); targetPoint.y = Math.max(0, Math.min(canvas.height, mouseY)); piState.needsRedraw = true; } else { const scaledRadius = piState.dragPointRadius_base * (canvas.width / DESIGN_WIDTH) * 1.5; if (Math.hypot(mouseX - piState.pointA.x, mouseY - piState.pointA.y) < scaledRadius || Math.hypot(mouseX - piState.pointB.x, mouseY - piState.pointB.y) < scaledRadius) { canvas.classList.add('pi-hover'); } else { canvas.classList.remove('pi-hover'); } } }); window.addEventListener('mouseup', (e) => { if (piState.draggingPoint) { generatePaths(); piState.draggingPoint = null; canvas.classList.remove('pi-dragging'); const moveEvent = new MouseEvent('mousemove', { bubbles: true, cancelable: true, clientX: e.clientX, clientY: e.clientY }); canvas.dispatchEvent(moveEvent); } }); canvas.addEventListener('mouseleave', () => { if (!piState.draggingPoint) { canvas.classList.remove('pi-hover'); } }); }
        
        function animationLoop(timestamp) { if (!canvas || !ctx) return; animationFrameId = requestAnimationFrame(animationLoop); const deltaTime = Math.min((timestamp - lastTimestamp) || 0, 50); lastTimestamp = timestamp; frameCount++; if (timestamp - lastFpsUpdate > 1000) { fpsDisplay.textContent = frameCount; frameCount = 0; lastFpsUpdate = timestamp; } let visualItemCount = 0; if (currentMode === 'double-slit') { updateDoubleSlit_main(deltaTime); visualItemCount = dsState.mainThreadParticles.length; } else { visualItemCount = piState.paths.length; } particleCountDisplay.textContent = visualItemCount; let needsClearAndDraw = currentMode === 'double-slit' || (currentMode === 'path-integral' && piState.needsRedraw); if (needsClearAndDraw) { ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height); } if (currentMode === 'double-slit') { renderDoubleSlit(); } else if (currentMode === 'path-integral') { if (piState.needsRedraw) { renderPathIntegral(); piState.needsRedraw = false; } } }
        
        function emitParticle_main() { const angle = (Math.random() - 0.5) * 0.6; const speed_scaled = dsParams.particleSpeed * (canvas.width / DESIGN_WIDTH); dsState.mainThreadParticles.push({ x: dsState.emitterX, y: dsState.emitterY, vx: speed_scaled * Math.cos(angle), vy: speed_scaled * Math.sin(angle), age: 0, maxAge: (canvas.width / Math.max(0.1, speed_scaled)) * 1.6, isWave: !dsParams.observer, passedSlitPlane: false, slitPassed: 0 }); }
        
        function updateDoubleSlit_main(deltaTime) { 
            mainThreadTimeSinceLastEmission += deltaTime; 
            
            const targetVisualCount = MAIN_THREAD_MAX_VISUALS; 
            const mainThreadEmissionRate = Math.min(MAIN_THREAD_EMISSION_RATE_LIMIT, targetVisualCount * 2);
            const mainThreadEmissionInterval = 1000 / mainThreadEmissionRate; 

            while (mainThreadTimeSinceLastEmission >= mainThreadEmissionInterval && dsState.mainThreadParticles.length < targetVisualCount * 1.2) { 
                emitParticle_main(); 
                mainThreadTimeSinceLastEmission -= mainThreadEmissionInterval; 
            } 
            
            for (let i = dsState.mainThreadParticles.length - 1; i >= 0; i--) { 
                const p = dsState.mainThreadParticles[i]; const prevX = p.x; p.x += p.vx; p.y += p.vy; p.age++; 
                if (p.age > p.maxAge || p.x < -10 || p.y < -10 || p.y > canvas.height + 10 || p.x > canvas.width + 20) { dsState.mainThreadParticles.splice(i, 1); continue; } 
                
                if (!p.passedSlitPlane && p.x >= dsState.barrierX && prevX < dsState.barrierX + dsState.barrierThickness) { 
                    let yAtBarrierFront = p.y; if (prevX < dsState.barrierX && p.x >= dsState.barrierX) { const t = (dsState.barrierX - prevX) / (p.vx || 1e-6); yAtBarrierFront = (p.y - p.vy) + p.vy * t; } 
                    p.passedSlitPlane = true; 
                    const actualSlitSeparation = dsParams.slitSeparation * (canvas.height / DESIGN_HEIGHT); 
                    const actualSlitHeight = dsParams.slitHeight * (canvas.height / DESIGN_HEIGHT); 
                    const slit1_y_top = dsState.emitterY - actualSlitSeparation / 2 - actualSlitHeight / 2; 
                    const slit1_y_bottom = slit1_y_top + actualSlitHeight; 
                    const slit2_y_top = dsState.emitterY + actualSlitSeparation / 2 - actualSlitHeight / 2; 
                    const slit2_y_bottom = slit2_y_top + actualSlitHeight; 
                    const inSlit1 = (yAtBarrierFront >= slit1_y_top && yAtBarrierFront <= slit1_y_bottom); 
                    const inSlit2 = (yAtBarrierFront >= slit2_y_top && yAtBarrierFront <= slit2_y_bottom); 

                    if (!inSlit1 && !inSlit2 && p.x < dsState.barrierX + dsState.barrierThickness) { dsState.mainThreadParticles.splice(i, 1); continue; } 
                    if (!inSlit1 && !inSlit2) { dsState.mainThreadParticles.splice(i, 1); continue; } 
                    
                    let y_final_on_detector; 
                    const distSlitScreen = dsState.detectorX - (dsState.barrierX); 
                    const speed_scaled = dsParams.particleSpeed * (canvas.width / DESIGN_WIDTH); 

                    if (p.isWave) { 
                        p.slitPassed = inSlit1 ? 1 : (inSlit2 ? 2 : 0); 
                        const lambda = dsParams.lambdaConstant / Math.max(0.1, speed_scaled); 
                        let attempts = 0; const MAX_ATTEMPTS = 250; 
                        while (attempts < MAX_ATTEMPTS) { 
                            const rand_y_rel = (Math.random() - 0.5) * (dsState.detectorHeight * 1.5); 
                            const sinc_arg = (Math.PI * actualSlitHeight * rand_y_rel) / (lambda * distSlitScreen); 
                            let diff_factor = (Math.abs(sinc_arg) > 1e-6) ? Math.pow(Math.sin(sinc_arg) / sinc_arg, 2) : 1.0; 
                            const int_arg = Math.PI * actualSlitSeparation * rand_y_rel / (lambda * distSlitScreen); 
                            const int_factor = Math.pow(Math.cos(int_arg), 2); 
                            if (Math.random() < (diff_factor * int_factor)) { y_final_on_detector = dsState.emitterY + rand_y_rel; break; } 
                            attempts++; 
                        } 
                        if (y_final_on_detector === undefined) { const target_y_offset = (yAtBarrierFront - dsState.emitterY) * (distSlitScreen / (dsState.barrierX - dsState.emitterX)); y_final_on_detector = dsState.emitterY + target_y_offset; } 
                    } else { 
                        p.slitPassed = inSlit1 ? 1 : 2; 
                        const y_slit_center = (p.slitPassed === 1) ? (slit1_y_top + actualSlitHeight / 2) : (slit2_y_top + actualSlitHeight / 2); 
                        const ideal_y = dsState.emitterY + (y_slit_center - dsState.emitterY) * (dsState.detectorX - dsState.emitterX) / (dsState.barrierX - dsState.emitterX); 
                        const max_spread = distSlitScreen * Math.tan(dsParams.observerKickStrength); 
                        y_final_on_detector = ideal_y + (Math.random() - 0.5) * 2 * max_spread; 
                    } 
                    const angle_target = Math.atan2(y_final_on_detector - p.y, dsState.detectorX - p.x); 
                    p.vx = speed_scaled * Math.cos(angle_target); p.vy = speed_scaled * Math.sin(angle_target); 
                } 
                if (p.x - p.vx < dsState.detectorX && p.x >= dsState.detectorX) { dsState.mainThreadParticles.splice(i, 1); continue; } 
            } 
        }
        function renderDoubleSlit() { ctx.fillStyle = '#888888'; const barrierRenderX = dsState.barrierX; const scaledSlitSeparation = dsParams.slitSeparation * (canvas.height / DESIGN_HEIGHT); const scaledSlitHeight = dsParams.slitHeight * (canvas.height / DESIGN_HEIGHT); const s1_top = dsState.emitterY - scaledSlitSeparation / 2 - scaledSlitHeight / 2; const s1_bottom = s1_top + scaledSlitHeight; const s2_top = dsState.emitterY + scaledSlitSeparation / 2 - scaledSlitHeight / 2; const s2_bottom = s2_top + scaledSlitHeight; if (s1_top > 0) ctx.fillRect(barrierRenderX, 0, dsState.barrierThickness, s1_top); const middle_barrier_height = s2_top - s1_bottom; if (middle_barrier_height > 0) ctx.fillRect(barrierRenderX, s1_bottom, dsState.barrierThickness, middle_barrier_height); if (s2_bottom < canvas.height) ctx.fillRect(barrierRenderX, s2_bottom, dsState.barrierThickness, canvas.height - s2_bottom); const emitterRadius = canvas.width * (5.5 / DESIGN_WIDTH); ctx.fillStyle = 'hsl(0, 100%, 60%)'; ctx.beginPath(); ctx.arc(dsState.emitterX, dsState.emitterY, emitterRadius, 0, 2 * Math.PI); ctx.fill(); const particleRadius = Math.max(1, canvas.width * (2.5 / DESIGN_WIDTH)); 
            dsState.mainThreadParticles.forEach(p => {
                const baseOpacity = 0.9; 
                let particleColor; 
                if (dsParams.observer) {particleColor = p.slitPassed === 1 ? `hsla(35,100%,60%,${baseOpacity})` : p.slitPassed === 2 ? `hsla(200,100%,60%,${baseOpacity})` : `hsla(180,100%,65%,${baseOpacity})`;} 
                else {particleColor = `hsla(180,100%,65%,${baseOpacity})`;} 
                ctx.fillStyle = particleColor; ctx.beginPath(); ctx.arc(p.x, p.y, particleRadius, 0, 2 * Math.PI); ctx.fill(); 
            }); 
            ctx.fillStyle = '#454545'; ctx.fillRect(dsState.detectorX, dsState.detectorStartY, dsState.detectorWidth, dsState.detectorHeight); const binRH = dsState.detectorHeight / dsState.HISTOGRAM_BINS, maxBL = canvas.width - (dsState.detectorX + dsState.detectorWidth) - (canvas.width * (15/DESIGN_WIDTH)) ; for (let i = 0; i < dsState.HISTOGRAM_BINS; i++) { if (dsState.histogram[i] > 0) { const normC = dsState.histogram[i] / (dsState.maxHistogramValue || 1); const lightness = 50 + normC * 40; const alpha = 0.5 + normC * 0.5; ctx.fillStyle = `hsla(190, 100%, ${lightness}%, ${alpha})`; ctx.fillRect(dsState.detectorX + dsState.detectorWidth + (canvas.width * (2/DESIGN_WIDTH)), dsState.detectorStartY + i * binRH, normC * maxBL, binRH); } } 
        }
        function generatePaths() { piState.paths = []; piState.minAction = Infinity; piState.maxAction = 0; piState.minActionPath = null; const { A, B } = { A: piState.pointA, B: piState.pointB }; const scaledWiggleAmplitude = piParams.wiggleAmplitude * (canvas.width / DESIGN_WIDTH); for (let i = 0; i < piParams.numPaths; i++) { const pts = [{ ...A }]; let act = 0; for (let j = 1; j < piParams.numSegments; j++) { const t = j / piParams.numSegments; const iX = A.x * (1 - t) + B.x * t; const iY = A.y * (1 - t) + B.y * t; pts.push({ x: iX + (Math.random() - .5) * scaledWiggleAmplitude, y: iY + (Math.random() - .5) * scaledWiggleAmplitude }); } pts.push({ ...B }); for (let k = 0; k < pts.length - 1; k++) act += Math.hypot(pts[k+1].x - pts[k].x, pts[k+1].y - pts[k].y); piState.paths.push({ points: pts, action: act }); if (act < piState.minAction) { piState.minAction = act; piState.minActionPath = pts; } if (act > piState.maxAction) piState.maxAction = act; } if (piState.minAction === piState.maxAction && piState.maxAction !== 0) piState.maxAction += 1e-6; else if(piState.minAction === piState.maxAction && piState.maxAction === 0) piState.maxAction = 1e-6; renderPathsToOffscreenCanvas(); piState.needsRedraw = true; }
        function renderPathsToOffscreenCanvas() { if (!piState.offscreenCtx) return; const oCtx = piState.offscreenCtx; oCtx.clearRect(0, 0, piState.offscreenCanvas.width, piState.offscreenCanvas.height); const lineWidthBase = Math.max(0.5, piState.offscreenCanvas.width * (1/DESIGN_WIDTH)); const minActionLineWidth = Math.max(1, piState.offscreenCanvas.width * (2.5/DESIGN_WIDTH)); piState.paths.forEach(pd => { if (pd.points === piState.minActionPath) return; const { points: pts, action: act } = pd, dAct = act - piState.minAction, actR = Math.max(1e-6, piState.maxAction - piState.minAction); let relAct = Math.min(1, Math.max(0, dAct / actR)), hue = 120 * (1 - relAct), opac = PI_CONSTS.MAX_PATH_OPACITY * (1 - Math.sqrt(relAct)); opac = Math.max(PI_CONSTS.MIN_PATH_OPACITY, opac); oCtx.strokeStyle = `hsla(${hue},100%,50%,${opac})`; oCtx.lineWidth = lineWidthBase; oCtx.beginPath(); oCtx.moveTo(pts[0].x, pts[0].y); for (let k = 1; k < pts.length; k++)oCtx.lineTo(pts[k].x, pts[k].y); oCtx.stroke(); }); if (piState.minActionPath) { oCtx.strokeStyle = '#00ff00'; oCtx.lineWidth = minActionLineWidth; oCtx.beginPath(); oCtx.moveTo(piState.minActionPath[0].x, piState.minActionPath[0].y); for (let k = 1; k < piState.minActionPath.length; k++) oCtx.lineTo(piState.minActionPath[k].x, piState.minActionPath[k].y); oCtx.stroke(); } }
        function renderPathIntegral() { if (piState.offscreenCanvas) { ctx.drawImage(piState.offscreenCanvas, 0, 0); } const pointRadius = Math.max(2, piState.dragPointRadius_base * (canvas.width / DESIGN_WIDTH)); ctx.fillStyle = 'hsl(0, 100%, 60%)'; ctx.font = `${Math.max(10, canvas.width * (14/DESIGN_WIDTH))}px Segoe UI`; ctx.beginPath(); ctx.arc(piState.pointA.x, piState.pointA.y, pointRadius, 0, 2 * Math.PI); ctx.fill(); ctx.fillText('A', piState.pointA.x - pointRadius*2.5, piState.pointA.y + pointRadius*0.8); ctx.beginPath(); ctx.arc(piState.pointB.x, piState.pointB.y, pointRadius, 0, 2 * Math.PI); ctx.fill(); ctx.fillText('B', piState.pointB.x + pointRadius*1.7, piState.pointB.y + pointRadius*0.8); }
        
        window.addEventListener('blur', () => { if (animationFrameId) cancelAnimationFrame(animationFrameId); });
        window.addEventListener('focus', () => { lastTimestamp = performance.now(); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(animationLoop); });
    </script>
</body>
</html>
